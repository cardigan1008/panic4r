From 5407d106b2aef21ae9a4ff598dd2d996e52b2707 Mon Sep 17 00:00:00 2001
From: Tom Milligan <tom@reinfer.io>
Date: Sat, 2 Apr 2022 08:53:45 +0100
Subject: [PATCH] fix: deleted trailing newline causes panic

---
 pretty_assertions/src/printer.rs | 129 +++++++++++++++++++++++++++++--
 1 file changed, 123 insertions(+), 6 deletions(-)

diff --git a/pretty_assertions/src/printer.rs b/pretty_assertions/src/printer.rs
index 0f7a631..af3e3e6 100644
--- a/pretty_assertions/src/printer.rs
+++ b/pretty_assertions/src/printer.rs
@@ -29,7 +29,7 @@ pub(crate) fn write_header(f: &mut fmt::Formatter) -> fmt::Result {
 /// Delay formatting this deleted chunk until later.
 ///
 /// It can be formatted as a whole chunk by calling `flush`, or the inner value
-/// obtained with `take` for further processing.
+/// obtained with `take` for further processing (such as an inline diff).
 #[derive(Default)]
 struct LatentDeletion<'a> {
     // The most recent deleted line we've seen
@@ -47,7 +47,7 @@ impl<'a> LatentDeletion<'a> {
 
     /// Take the underlying chunk value, if it's suitable for inline diffing.
     ///
-    /// If there is no value of we've seen more than one line, return `None`.
+    /// If there is no value or we've seen more than one line, return `None`.
     fn take(&mut self) -> Option<&'a str> {
         if self.count == 1 {
             self.value.take()
@@ -100,10 +100,6 @@ pub(crate) fn write_lines<TWrite: fmt::Write>(
                 previous_deletion.flush(f)?;
                 previous_deletion.set(deleted);
             }
-            // Underlying diff library should never return this sequence
-            (::diff::Result::Right(_), Some(::diff::Result::Left(_))) => {
-                panic!("insertion followed by deletion");
-            }
             // If we're being followed by more insertions, don't inline diff
             (::diff::Result::Right(inserted), Some(::diff::Result::Right(_))) => {
                 previous_deletion.flush(f)?;
@@ -478,4 +474,125 @@ Cabbage"#;
 
         check_printer(write_lines, left, right, &expected);
     }
+
+    mod write_lines_edge_newlines {
+        use super::*;
+
+        #[test]
+        fn both_trailing() {
+            let left = "fan\n";
+            let right = "mug\n";
+            // Note the additional space at the bottom is caused by a trailing newline
+            // adding an additional line with zero content to both sides of the diff
+            let expected = format!(
+                r#"{red_light}<{reset}{red_heavy}fan{reset}
+{green_light}>{reset}{green_heavy}mug{reset}
+ 
+"#,
+                red_light = RED_LIGHT,
+                red_heavy = RED_HEAVY,
+                green_light = GREEN_LIGHT,
+                green_heavy = GREEN_HEAVY,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+
+        #[test]
+        fn both_leading() {
+            let left = "\nfan";
+            let right = "\nmug";
+            // Note the additional space at the top is caused by a leading newline
+            // adding an additional line with zero content to both sides of the diff
+            let expected = format!(
+                r#" 
+{red_light}<{reset}{red_heavy}fan{reset}
+{green_light}>{reset}{green_heavy}mug{reset}
+"#,
+                red_light = RED_LIGHT,
+                red_heavy = RED_HEAVY,
+                green_light = GREEN_LIGHT,
+                green_heavy = GREEN_HEAVY,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+
+        #[test]
+        fn leading_added() {
+            let left = "fan";
+            let right = "\nmug";
+            let expected = format!(
+                r#"{red_light}<fan{reset}
+{green_light}>{reset}
+{green_light}>mug{reset}
+"#,
+                red_light = RED_LIGHT,
+                green_light = GREEN_LIGHT,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+
+        #[test]
+        fn leading_deleted() {
+            let left = "\nfan";
+            let right = "mug";
+            let expected = format!(
+                r#"{red_light}<{reset}
+{red_light}<fan{reset}
+{green_light}>mug{reset}
+"#,
+                red_light = RED_LIGHT,
+                green_light = GREEN_LIGHT,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+
+        #[test]
+        fn trailing_added() {
+            let left = "fan";
+            let right = "mug\n";
+            let expected = format!(
+                r#"{red_light}<fan{reset}
+{green_light}>mug{reset}
+{green_light}>{reset}
+"#,
+                red_light = RED_LIGHT,
+                green_light = GREEN_LIGHT,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+
+        /// Regression test for double abort
+        ///
+        /// See: https://github.com/colin-kiegel/rust-pretty-assertions/issues/96
+        #[test]
+        fn trailing_deleted() {
+            // The below inputs caused an abort via double panic
+            // we panicked at 'insertion followed by deletion'
+            let left = "fan\n";
+            let right = "mug";
+            let expected = format!(
+                r#"{red_light}<{reset}{red_heavy}fan{reset}
+{green_light}>{reset}{green_heavy}mug{reset}
+{red_light}<{reset}
+"#,
+                red_light = RED_LIGHT,
+                red_heavy = RED_HEAVY,
+                green_light = GREEN_LIGHT,
+                green_heavy = GREEN_HEAVY,
+                reset = RESET,
+            );
+
+            check_printer(write_lines, left, right, &expected);
+        }
+    }
 }
-- 
2.34.1

