From 2ed15d5f5862718fca90859b35459abf088d3b76 Mon Sep 17 00:00:00 2001
From: David Tolnay <dtolnay@gmail.com>
Date: Sat, 1 Sep 2018 08:46:12 -0700
Subject: [PATCH] Hide panic output in nightly_works

---
 src/unstable.rs | 39 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 36 insertions(+), 3 deletions(-)

diff --git a/src/unstable.rs b/src/unstable.rs
index e62c86a..4706ca7 100644
--- a/src/unstable.rs
+++ b/src/unstable.rs
@@ -23,16 +23,49 @@ pub enum LexError {
 
 fn nightly_works() -> bool {
     use std::sync::atomic::*;
+    use std::sync::Once;
+
     static WORKS: AtomicUsize = ATOMIC_USIZE_INIT;
+    static INIT: Once = Once::new();
 
     match WORKS.load(Ordering::SeqCst) {
         1 => return false,
         2 => return true,
         _ => {}
     }
-    let works = panic::catch_unwind(|| proc_macro::Span::call_site()).is_ok();
-    WORKS.store(works as usize + 1, Ordering::SeqCst);
-    works
+
+    // Swap in a null panic hook to avoid printing "thread panicked" to stderr,
+    // then use catch_unwind to determine whether the compiler's proc_macro is
+    // working. When proc-macro2 is used from outside of a procedural macro all
+    // of the proc_macro crate's APIs currently panic.
+    //
+    // The Once is to prevent the possibility of this ordering:
+    //
+    //     thread 1 calls take_hook, gets the user's original hook
+    //     thread 1 calls set_hook with the null hook
+    //     thread 2 calls take_hook, thinks null hook is the original hook
+    //     thread 2 calls set_hook with the null hook
+    //     thread 1 calls set_hook with the actual original hook
+    //     thread 2 calls set_hook with what it thinks is the original hook
+    //
+    // in which the user's hook has been lost.
+    //
+    // There is still a race condition where a panic in a different thread can
+    // happen during the interval that the user's original panic hook is
+    // unregistered such that their hook is incorrectly not called. This is
+    // sufficiently unlikely and less bad than printing panic messages to stderr
+    // on correct use of this crate. Maybe there is a libstd feature request
+    // here. For now, if a user needs to guarantee that this failure mode does
+    // not occur, they need to call e.g. `proc_macro2::Span::call_site()` from
+    // the main thread before launching any other threads.
+    INIT.call_once(|| {
+        let original_hook = panic::take_hook();
+        panic::set_hook(Box::new(|_panic_info| { /* ignore */ }));
+        let works = panic::catch_unwind(|| proc_macro::Span::call_site()).is_ok();
+        WORKS.store(works as usize + 1, Ordering::SeqCst);
+        panic::set_hook(original_hook);
+    });
+    nightly_works()
 }
 
 fn mismatch() -> ! {
-- 
2.25.1

