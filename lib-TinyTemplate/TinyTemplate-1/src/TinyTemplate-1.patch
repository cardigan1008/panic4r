From 2881955d98e3fd17ba48607f44cf1fcfb159a5d6 Mon Sep 17 00:00:00 2001
From: Andreas Molzer <andreas.molzer@gmx.de>
Date: Thu, 14 Jul 2022 20:37:48 +0200
Subject: [PATCH] Fix malformed closing tag

When closing a tag (block, or other), the search function did not
consider that the start and end tags can overlap in their symbols. It
also assumes a minimum length for the matching sequence based on a
complete start and complete end tag. These combined would cause range
errors by accessing the incorrect content such as:

	{#}

	// src/compiler.rs:58
	comment = tag[2..1].trim()

This is fixed by skipping the start tag for the purpose of searching for
the end tag, assuming the start tag has equal with.
---
 src/compiler.rs | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/compiler.rs b/src/compiler.rs
index cb5eef8..f28973d 100644
--- a/src/compiler.rs
+++ b/src/compiler.rs
@@ -348,10 +348,17 @@ impl<'template> TemplateCompiler<'template> {
     /// Advance the cursor to after the given expected_close string and return the text in between
     /// (including the expected_close characters), or return an error message if we reach the end
     /// of a line of text without finding it.
+    /// Assumes that there's a start token with the same length as the close token at the start of
+    /// currently remaining text.
     fn consume_tag(&mut self, expected_close: &str) -> Result<&'template str> {
+        // We skip over the matching start token for this tag, so that we do not accidentally match
+        // some suffix of it with the close token. We assume that the start token is as long as the
+        // end token.
+        let start_len = expected_close.len();
+        let end_len = expected_close.len();
         if let Some(line) = self.remaining_text.lines().next() {
-            if let Some(pos) = line.find(expected_close) {
-                let (tag, remaining) = self.remaining_text.split_at(pos + expected_close.len());
+            if let Some(pos) = line[start_len..].find(expected_close) {
+                let (tag, remaining) = self.remaining_text.split_at(pos + start_len + end_len);
                 self.remaining_text = remaining;
                 Ok(tag)
             } else {